# -*- coding: utf-8 -*-
"""backtest_strategies_trading

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Uab2vhFaqEDUzjmrIhJqSXnhRGat3qa

# "Backtest d'une stratégie de trading sur la paire ETH/USDT. La stratégie est assez simple : elle repose sur l'étude du croisement de deux moyennes mobiles exponentielles pour déterminer nos points d'entrée et de sortie. Nous chercherons à lisser les positions en utilisant le RSI, un indicateur stochastique qui nous aidera à éviter les zones de surachat et de survente. Nous envisageons d'optimiser les longueurs des moyennes mobiles, mais pas celles du RSI, afin d'éviter tout risque de surapprentissage. Bien que la stratégie soit conçue pour être appliquée sur une base horaire, elle pourrait tout aussi bien être adaptée pour une analyse hebdomadaire ou quotidienne. Cette adaptation pourrait être pertinente car les moyennes mobiles seraient moins sensibles aux fluctuations de prix."
"""

pip install python-binance

pip install ta

pip install pandas_ta

"""IMPORT DATASET"""

import pandas as pd
from binance.client import Client
import ta
import matplotlib.pyplot as plt

klinesT = Client().get_historical_klines("ETHUSDT", Client.KLINE_INTERVAL_1HOUR, "01 january 2021")
df = pd.DataFrame(klinesT, columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'quote_av', 'trades', 'tb_base_av', 'tb_quote_av', 'ignore' ])


df = pd.DataFrame(klinesT, columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume', 'close_time', 'quote_av', 'trades', 'tb_base_av', 'tb_quote_av', 'ignore' ])
df['close'] = pd.to_numeric(df['close'])
df['high'] = pd.to_numeric(df['high'])
df['low'] = pd.to_numeric(df['low'])
df['open'] = pd.to_numeric(df['open'])

del df['ignore']
del df['close_time']
del df['quote_av']
del df['trades']
del df['tb_base_av']
del df['tb_quote_av']

df = df.set_index(df['timestamp'])
df.index = pd.to_datetime(df.index, unit='ms')
del df['timestamp']
print(df)

"""INDICATOR INITIALIZATION"""

dfTest = df.copy()

dfTest['EMA25']=ta.trend.ema_indicator(dfTest['close'], 25)
dfTest['EMA33']=ta.trend.ema_indicator(dfTest['close'], 33)
dfTest['STOCH_RSI']=ta.momentum.stochrsi(dfTest['close'])

dfTest

"""FOR OTHER STRATEGY"""

#dfTest = df.copy()
# dfTest['histo_macd']=ta.trend.macd_diff(dfTest['close'], 26, 12, 9)
# dfTest['MACD']=ta.trend.macd(dfTest['close'], 26, 12, 9)
# dfTest['MACD_SIGNAL']=ta.trend.macd_signal(dfTest['close'], 26, 12, 9)
# dfTest['MACD_HISTO']= dfTest['MACD'] - dfTest['MACD_SIGNAL']
# dfTest['EMA8']=ta.trend.ema_indicator(dfTest['close'], 8)
# dfTest['EMA14']=ta.trend.ema_indicator(dfTest['close'], 14)
# dfTest['EMA25']=ta.trend.ema_indicator(dfTest['close'], 25)
# dfTest['EMA33']=ta.trend.ema_indicator(dfTest['close'], 33)
# dfTest['EMA50']=ta.trend.ema_indicator(dfTest['close'], 50)
# dfTest['STOCH_RSI']=ta.momentum.stochrsi(dfTest['close'])
# dfTest['MEAN_STOCH_RSI'] = ta.trend.sma_indicator(dfTest['STOCH_RSI'], 3)
# dfTest['SIGNAL_MEAN_STOCH_RSI'] = ta.trend.sma_indicator(dfTest['MEAN_STOCH_RSI'], 3)
# dfTest['MEAN_STOCH_RSI'] = ta.trend.sma_indicator(dfTest['STOCH_RSI'], 3)
# dfTest['SIGNAL_MEAN_STOCH_RSI'] = ta.trend.sma_indicator(dfTest['MEAN_STOCH_RSI'], 3)
#dfTest

"""EXTRACT BEST PARAMETERS (OPTIMIZATION)"""

dt = None
dt = pd.DataFrame(columns = ['i','j', 'result'])
count=0
for i in range(25,50,3):
  dfTest["EMA1"] = ta.trend.ema_indicator(dfTest['close'], i)
  for j in range(i+2,70,3):
    dfTest["EMA2"] = ta.trend.ema_indicator(dfTest['close'], j)
    dfTest["EMA_HISTO"] = dfTest["EMA1"] - dfTest["EMA2"]

    usdt = 1000
    coin = 0
    fee = 0.0007

    for index, row in dfTest.iterrows():
      #buy
      if row['EMA_HISTO'] > 0 and row['STOCH_RSI'] < 0.8 and usdt > 0:
        coin = usdt/row['close'] - fee*usdt/row['close']
        usdt = 0

      #sell
      elif row['EMA_HISTO'] < 0 and row['STOCH_RSI'] > 0.2 and coin > 0:
        usdt = coin*row['close'] - fee*coin*row['close']
        if usdt < 250:
          break
        coin = 0

    myrow = {'i': i, 'j': j,'result': usdt + coin*dfTest.iloc[-1]['close']}
    dt = dt.append(myrow,ignore_index=True)
print(dt.sort_values(by=['result']))
dt.plot.scatter(x='i',y='j',c='result',s=50,colormap='seismic')
plt.show()

"""on peut deduire que il nous faut des ema entre 25 et 40

EXECUTION
"""

dt = None
dt = pd.DataFrame(columns = ['date','position', 'price', 'frais' ,'fiat', 'coins', 'wallet', 'drawBack'])

busd = 1000
initalWallet = busd
coin = 0
wallet = 1000
lastAth = 0
lastIndex = df.first_valid_index()
fee = 0.0007

for index, row in dfTest.iterrows():
  #Buy
  if row['EMA25'] > row['EMA33'] and row['STOCH_RSI'] < 0.8 and  busd > 0:
    coin = busd / row['close']
    frais = fee * coin
    coin = coin - frais
    busd = 0
    wallet = coin * row['close']
    if wallet > lastAth:
      lastAth = wallet

    myrow = {'date': index,'position': "Buy",'price': row['close'],'frais': frais * row['close'],'fiat': busd,'coins': coin,'wallet': wallet,'drawBack':(wallet-lastAth)/lastAth}
    dt = dt.append(myrow,ignore_index=True)

  #Sell
  if row['EMA25'] < row['EMA33'] and row['STOCH_RSI'] > 0.2 and coin > 0:
    busd = coin * row['close']
    frais = fee * busd
    busd = busd - frais
    coin = 0
    wallet = busd
    if wallet > lastAth:
      lastAth = wallet

    myrow = {'date': index,'position': "Sell",'price': row['close'],'frais': frais,'fiat': busd,'coins': coin,'wallet': wallet,'drawBack':(wallet-lastAth)/lastAth}
    dt = dt.append(myrow,ignore_index=True)

  lastIndex = index

# Conclusion and plot

print("Period : [" + str(dfTest.index[0]) + "] -> [" +str(dfTest.index[len(dfTest)-1]) + "]")
dt = dt.set_index(dt['date'])
dt.index = pd.to_datetime(dt.index)
dt['resultat'] = dt['wallet'].diff()
dt['resultat%'] = dt['wallet'].pct_change()*100
dt.loc[dt['position']=='Buy','resultat'] = None
dt.loc[dt['position']=='Buy','resultat%'] = None

dt['tradeIs'] = ''
dt.loc[dt['resultat']>0,'tradeIs'] = 'Good'
dt.loc[dt['resultat']<=0,'tradeIs'] = 'Bad'

iniClose = dfTest.iloc[0]['close']
lastClose = dfTest.iloc[len(dfTest)-1]['close']
holdPorcentage = ((lastClose - iniClose)/iniClose) * 100
algoPorcentage = ((wallet - initalWallet)/initalWallet) * 100
vsHoldPorcentage = ((algoPorcentage - holdPorcentage)/holdPorcentage) * 100

print("Starting balance : 1000 $")
print("Final balance :",round(wallet,2),"$")
print("Performance vs US Dollar :",round(algoPorcentage,2),"%")
print("Buy and Hold Performence :",round(holdPorcentage,2),"%")
print("Performance vs Buy and Hold :",round(vsHoldPorcentage,2),"%")
print("Number of negative trades : ",dt.groupby('tradeIs')['date'].nunique()['Bad'])
print("Number of positive trades : ",dt.groupby('tradeIs')['date'].nunique()['Good'])
print("Average Positive Trades : ",round(dt.loc[dt['tradeIs'] == 'Good', 'resultat%'].sum()/dt.loc[dt['tradeIs'] == 'Good', 'resultat%'].count(),2),"%")
print("Average Negative Trades : ",round(dt.loc[dt['tradeIs'] == 'Bad', 'resultat%'].sum()/dt.loc[dt['tradeIs'] == 'Bad', 'resultat%'].count(),2),"%")
idbest = dt.loc[dt['tradeIs'] == 'Good', 'resultat%'].idxmax()
idworst = dt.loc[dt['tradeIs'] == 'Bad', 'resultat%'].idxmin()
print("Best trade +"+str(round(dt.loc[dt['tradeIs'] == 'Good', 'resultat%'].max(),2)),"%, the ",dt['date'][idbest])
print("Worst trade",round(dt.loc[dt['tradeIs'] == 'Bad', 'resultat%'].min(),2),"%, the ",dt['date'][idworst])
print("Worst drawBack", str(100*round(dt['drawBack'].min(),2)),"%")
print("Total fee : ",round(dt['frais'].sum(),2),"$")

dt[['wallet','price']].plot(subplots=True, figsize=(12,10))
print('PLOT')

"""Ce code fut très long et compliqué à faire. Les résultats me semblent corrects, mais je ne suis pas assez expert pour le confirmer. Cependant, la création de ce code m'a exposé à de nombreux concepts d'optimisation tels que le surapprentissage,sous-apprentissage, ainsi que l'échantillonnage de la base de données"""